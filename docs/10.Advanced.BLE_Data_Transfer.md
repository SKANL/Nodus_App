# 10. Advanced: BLE Data Transfer & Chunking

> **Status:** Draft
> **Problem:** BLE MTU is tiny (23-512 bytes). Voting Forms are large (2KB+).

## 1. The "Chunking" Protocol

Since we cannot rely on the OS to handle large packets automatically across all Android/iOS versions reliably, we implement an **Application-Layer Chunking** protocol.

### A. Envelope Structure (The "Meta-Packet")

Before sending the data, we send a **Header**:

```csharp
[StructLayout(LayoutKind.Sequential, Pack = 1)]
struct ChunkHeader {
    byte MessageId;       // Unique ID for this transfer (0-255)
    byte ChunkIndex;      // 0 = Header, 1..N = Data
    byte TotalChunks;     // Total packet count
    ushort PayloadLength; // Total bytes (sanity check)
}
```

### B. The Sequence

1.  **Sender** breaks JSON into `N` chunks of size `(CurrentMtu - 4)`.
2.  **Sender** writes `Chunk 0` (Header).
3.  **Receiver** allocates buffer.
4.  **Sender** writes `Chunk 1..N` in a burst.
5.  **Receiver** assembles bytes.
6.  **Receiver** verifies `Ed25519` signature.
7.  **Receiver** sends `ACK` (on a refined Notification characteristic) OR purely relies on Application Logic "I saw it".

> **Note:** For "Fire and Forget" swarm logic, we might skip the ACK to save battery and reduce traffic, relying on the redundancy of multiple nodes receiving the broadcast.

## 2. MTU Negotiation

- **Android:** Can request MTU = 512.
- **iOS:** Fixed ~185 bytes for Application Data (mostly).
- **Strategy:** Assume **180 bytes** as the safe maximum payload per chunk to ensure cross-platform stability.

## 3. Implementation in Shiny.NET

```csharp
// Sender Logic
public async Task SendJsonAsync(string json) {
    var bytes = System.Text.Encoding.UTF8.GetBytes(json);
    var chunks = ChunkHelper.Split(bytes, size: 180);

    foreach(var chunk in chunks) {
        await _characteristic.Write(chunk, withResponse: false);
        await Task.Delay(10); // Throttle for stability
    }
}
```
